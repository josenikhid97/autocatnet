# -*- coding: utf-8 -*-
"""MaxRaf.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hEARQM8D3IgWGyUMWhVpOsGNFpiOFZW0
"""

# RAF algorithms
r1 = {
    "A":  ["a", "b"],
    "B": ["d"],
    "x": ["e", "f"]
}

r2 = {
    "A":  ["b", "c"],
    "B": ["e"],
    "x": ["f"]
}

r3 = {
    "A":  ["e", "c"],
    "B": ["b", "f"],
    "x": ["d"]
}

r4 = {
    "A":  ["c", "h"],
    "B": ["g"],
    "x": ["g"]
}

r5 = {
    "A":  ["i"],
    "B": ["h"],
    "x": ["h"]
}

r6 = {
    "A":  ["h"],
    "B": ["i"],
    "x": ["d"]
}

F = ["a", "b", "c"]

R = [r1, r2, r3, r4, r5, r6]

# Q = {X, R, C, F}

# To check if all reactants exist in the closure
def checkReact(reactantArr, W):
    status = []
    for reac in reactantArr:
        if (reac in W) == True:
            status.append(True)
        else:
            status.append(False)
    
    if (False in status):
        return False
    else:
        return True

# To find the unique maximal RAF set contained in Q
def maxRAF(R, F):
    R_prime = R
    change = True
    while change == True:
        change = False
        W = computeClosure(F, R_prime)
        for reaction in R_prime:
            # checking if any of the catalysts exists in W
            exists = False
            for catalyst in reaction["x"]:
                if (catalyst in W):
                    exists = True

            if (exists == False or checkReact(reaction["A"], W) == False):
                R_prime.remove(reaction)
                change = True
    return R_prime

# To compute the closure of F, relative to R_prime
def computeClosure(F, R_prime):
    W = F
    change = True
    while change == True:
        change = False
        for reaction in R_prime:
            if (checkReact(reaction["A"], W) == True and checkReact(reaction["B"], W) == False):
                W += reaction["B"]
                change = True
    return W

# Invoking the above functions
print(maxRAF(R, F))